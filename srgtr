using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace Ko.NBlink
{

    public class LocalServerConfig
    {
        public string RootPath { get; set; }
        public int? Port { get; set; }

        public string GetHostAddress()
        {
            if (!Port.HasValue)
            {
                var tcpl = new TcpListener(IPAddress.Loopback, 0);
                tcpl.Start();
                Port = ((IPEndPoint)tcpl.LocalEndpoint).Port;
                tcpl.Stop();
            }
            return $"http://*:{Port}/";
        }

        public string GetRootPath()
        {
            if (string.IsNullOrEmpty(RootPath))
            {
                RootPath = $"{AppContext.BaseDirectory}//Web";
            }
            return RootPath;
        }
    }


    public class LocalServer : IMessageHandler<StartCmd>, IMessageHandler<CleanUpCmd>
    {
        const string DefaultPage = "index.html";
        private readonly LocalServerConfig _serverConfig;
        private HttpListener _listener;
        private readonly string _rootPath;
        private readonly string _rootPrefix;
        private Thread _serverThread;

        public LocalServer(LocalServerConfig config)
        {
            _serverConfig = config;
            if (!HttpListener.IsSupported)
                throw new ApplicationException("Windows XP SP2 or Server 2003 is required to use the HttpListener class.");
            _rootPath = _serverConfig.GetRootPath(); if (!Directory.Exists(_rootPath))
                throw new ApplicationException($"{_rootPath} don't exist");
            _rootPrefix = _serverConfig.GetHostAddress();
        }


        public async Task Execute(StartCmd message, CancellationToken token)
        {

            _serverThread = new Thread(WaitforRequests)
            {
                IsBackground = true
            };
            _serverThread.Start();


            //Task.Factory.StartNew(()=> {
            //    var context = _listener.GetContext();
            //    ExecuteRequest(context);
            //});


            //Task.Factory.StartNew(()=> {


            //},token,TaskCreationOptions.LongRunning,TaskScheduler.Default);


            await Task.Delay(1);


            //Task.Run(() =>
            //{

            //    while (true)
            //    {
            //        var context =  _listener.GetContext();
            //        ExecuteRequest(context);
            //    }


            //});

        }

      

        public async Task Execute(CleanUpCmd message, CancellationToken token)
        {
            await Task.Delay(1);
            if (_listener != null && _listener.IsListening)
            {
                _listener.Stop();
            }
        }
        private void WaitforRequests()
        {
            _listener = new HttpListener();
            _listener.Prefixes.Add(_rootPrefix);
            _listener.Start();
            Console.WriteLine($"Started Running @ {_rootPrefix}");
            while (true)
            {
                var context = _listener.GetContext();
                ExecuteRequest(context);
            }
        }
        private void ExecuteRequest(HttpListenerContext context)
        {
            try
            {
                var resource = GetResourcePath(context);
                context.Response.ContentType = GetMimeHeader(Path.GetExtension(resource));
                context.Response.AddHeader("Date", DateTime.Now.ToString("r"));
                context.Response.AddHeader("Last-Modified", File.GetLastWriteTime(resource).ToString("r"));
                using (var rs = new FileStream(resource, FileMode.Open, FileAccess.Read))
                {
                    context.Response.ContentLength64 = rs.Length;
                    byte[] buffer = new byte[1024 * 16];
                    int read;
                    while ((read = rs.Read(buffer, 0, buffer.Length)) > 0)
                        context.Response.OutputStream.Write(buffer, 0, read);
                    rs.Close();
                }
                context.Response.StatusCode = (int)HttpStatusCode.OK;
            }
            catch (FileNotFoundException fex)
            {
                Console.WriteLine($":{fex}");
                context.Response.StatusCode = (int)HttpStatusCode.NotFound;
            }
            catch (Exception ex)
            {
                Console.WriteLine($":{ex}");
                context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
            }
            finally
            {
                context.Response.OutputStream.Flush();
                context.Response.OutputStream.Close();
            }
        }
        private string GetResourcePath(HttpListenerContext context)
        {
            var resource = context.Request?.Url?.AbsolutePath;
            if (string.IsNullOrEmpty(resource))
                throw new Exception("empty path specified");
            resource = resource.Substring(1);
            if (string.IsNullOrEmpty(resource))
                resource = DefaultPage;
            resource = Path.Combine(_rootPath, resource);
            if (!File.Exists(resource))
                throw new FileNotFoundException(resource);
            return resource.ToLower();
        }
        private string GetMimeHeader(string extention)
        {
            switch (extention)
            {
                case ".ico":
                    return "image/x-icon";
                case ".htm":
                case ".html":
                    return "text/html";
                case ".jpeg":
                case ".jpg":
                    return "image/jpeg";
                case ".png":
                    return "image/png";
                case ".js":
                    return "application/x-javascript";
                case ".css":
                    return "text/css";
                default:
                    return "application/octet-stream";
            }

        }

    }


}
